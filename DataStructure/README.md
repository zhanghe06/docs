# 数据结构 (Data Structure)

| 数据结构   | 定义、优点                                        | 缺点                                                              |
| ------ | -------------------------------------------- | --------------------------------------------------------------- |
| 二叉树    | 每个结点最多有两个子树，左子树比父节点小，右子树比父节点大                | 会出现极端情况导致整棵树只有左子树或只有右子树：当插入的节点都比前一个插入的节点大或小时，此时就会退化成了一条线性的存储结构了 |
| 平衡二叉树  | 任意一个节点的左子树和右子树的深度差小于等于1，这样能有效避免二叉搜索树退化成线性的情况 | AVL树是高度平衡的，频繁的插入和删除，会引起频繁的rebalance，导致效率下降。                     |
| 红黑树    | 放弃了追求完全平衡，追求大致平衡，保证每次插入最多只需要三次旋转就能达到平衡       | 数据量大会导致树层数比较多，这样就会造成查找数据慢。                                      |
| Hash表  | 散列表                                          | 精确查找十分快速，但范围查找就碰壁了。                                             |
| BTree  | 一个节点可以存储多个数据，这样可以避免黑红树的缺点，树的层数很变小            | 节点里面数组数据：每个数据的结构=索引数据+数据记录（即叶子节点存储键值和数据记录）。                     |
| B+Tree | 非叶子节点不存储data，只存储索引(冗余)，可以放更多的索引              | -                                                               |

HashMap的实现就是一个数组，然后数组中的每一个元素又是一个链表
当链表长度超过8的时候，将数据的存储从链表转变为使用红黑树
之所以使用红黑树，是因为红黑树的检索比链表要快的多，在链表中要查找某个元素，需要使用遍历的方式实现，此时查找需要的时间复杂度是O(n)，而对于红黑树来说，它需要的时间复杂度是O(logn)

## 进制

以小数`10.10`为例，理解不同进制

十进制表达式: 

$$
1 \times 10^1 + 0 \times 10^0 + 1 \times 10^{-1} + 0 \times 10^{-2} = 10.10
$$

二进制表达式: 

$$
1 \times 2^1 + 0 \times 2^0 + 1 \times 2^{-1} + 0 \times 2^{-2} = 2.50
$$

二进制小数部分的处理，解释了程序计算精度问题

```
In [1]: 3.0/3
Out[1]: 1.0

In [2]: 3.3/3
Out[2]: 1.0999999999999999
```
