# 日志系统 Log

设计原则

1. 服务入口的请求和响应日志没有特殊原因都要输出并采集，采集的字段可以根据需求调整。
2. 错误日志一般都要打印，如果太多，可以使用采样方式打印。
3. 减少无效日志输出，尤其是循环中打印日志的情况需尽量减少。
4. 请求型的日志(比如Ingress、Nginx访问日志)一般不超过5MB/s(500字节每条，不超过1W/s)，应用程序日志不超过200KB/s(2KB每条，不超过100条/s)。

注意：一定要确保日志打印是异步的，不能阻塞业务系统运行。

K8S 弹性伸缩的调度能力，使得容器动态生产和销毁，这样日志也会随时销毁，没办法保证日志的存储周期能够满足DevOps、审计等相关的需求。

在动态的环境下实现日志的长期存储只能通过中心化的日志存储来实现，通过实时的日志采集方式，将各个节点、各个容器的日志在秒级内采集到日志中心系统上，即使节点/容器挂掉也能够通过日志还原当时的现场。

虽然使用 Stdout 打印日志是 Docker 官方推荐的方式，但大家需要注意：这个推荐是基于容器只作为简单应用的场景，实际的业务场景中我们还是建议大家尽可能使用文件的方式，主要的原因有以下几点：

Stdout 性能问题，从应用输出 stdout 到服务端，中间会经过好几个流程(例如普遍使用的 JSON LogDriver)：应用 stdout -> DockerEngine -> LogDriver -> 序列化成 JSON -> 保存到文件 -> Agent 采集文件 -> 解析 JSON -> 上传服务端。整个流程相比文件的额外开销要多很多，在压测时，每秒 10 万行日志输出就会额外占用 DockerEngine 1 个 CPU 核；
Stdout 不支持分类，即所有的输出都混在一个流中，无法像文件一样分类输出，通常一个应用中有 AccessLog、ErrorLog、InterfaceLog(调用外部接口的日志)、TraceLog 等，而这些日志的格式、用途不一，如果混在同一个流中将很难采集和分析；
Stdout 只支持容器的主程序输出，如果是 daemon/fork 方式运行的程序将无法使用 stdout；
文件的 Dump 方式支持各种策略，例如同步/异步写入、缓存大小、文件轮转策略、压缩策略、清除策略等，相对更加灵活。

