# 缓存系统（Cache System）


## 更新策略

更新数据时，删除缓存而不是更新缓存：

1、避免写多读少场景下产生大量冷数据  
2、有些场景缓存可能需要多表数据组合  
3、后续当读取缓存为空也仅须读一次库


## 顺序策略

先删除缓存，再更新数据库

1、如果先更新数据库，当删除缓存失败，会产生数据不一致  
2、如果先删除缓存，当更新数据库失败，缓存为空数据一致  
3、如果删除缓存失败，为保持数据一致性，做更新失败处理


## 并发场景

为了描述清晰，简化并发模型，以下示例模拟2条并发请求，有一定概率出现以下情况：

序号 | 更新请求 | 读取请求
:---: | --- | ---
1 | 先删除了缓存 | -
2 | - | 读取缓存，缓存为空
3 | - | 查询数据库，得到旧数据
4 | 更新数据库 | -
5 | - | 旧数据存入缓存

导致数据不一致，咋办?

祭出神器：分布式锁

## 总结

一个业务逻辑单元如果包含多个原子操作，在并发场景下，需要考虑业务逻辑单元整体的原子性，就需要加个锁、或者通过队列排队啥的，保证业务逻辑单元串行，来解决一致性问题
